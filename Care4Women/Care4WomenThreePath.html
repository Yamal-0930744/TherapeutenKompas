<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Treasure Modal Game</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { display: block; }
    #modal {
      display: none;
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.6);
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    #modalContent {
      background: white;
      padding: 30px;
      border-radius: 12px;
      text-align: center;
    }
    #modalContent button {
      margin-top: 15px;
      padding: 8px 16px;
      border: 0;
      background: hotpink;
      color: white;
      border-radius: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>

<div id="modal">
  <div id="modalContent">
    <h2>ðŸŽ‰ Je hebt een schat gevonden!</h2>
    <p>Goed bezig! Je hebt net een schatkist geopend.</p>
    <button id="closeBtn">Sluiten</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

<script type="module">
  import {
    createMap,
    getWalkablePositions,
    getSpawnPosition,
    tileSize
  } from './ThreeJSMap.js';

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const clock = new THREE.Clock();

  scene.add(new THREE.AmbientLight(0xffffff, 0.3));
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(10, 30, 10);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 100;
  sun.shadow.camera.left = -30;
  sun.shadow.camera.right = 30;
  sun.shadow.camera.top = 30;
  sun.shadow.camera.bottom = -30;
  scene.add(sun);

  const gltfLoader = new THREE.GLTFLoader();
  createMap(scene, gltfLoader);

  const spawn = getSpawnPosition();
  const player = new THREE.Group();
  scene.add(player);

  gltfLoader.load('./assets/character-e.glb', gltf => {
    const model = gltf.scene;
    new THREE.TextureLoader().load('./assets/texture-e.png', tx => {
      model.traverse(c => {
        if (c.isMesh) {
          c.material = new THREE.MeshStandardMaterial({ map: tx, transparent: true });
          c.castShadow = c.receiveShadow = true;
        }
      });
      model.scale.set(0.65, 0.65, 0.65);
    });
    player.position.set(spawn.x, 0, spawn.z);
    player.add(model);
  });

  const playerPos = { x: spawn.x, z: spawn.z };
  const walkablePositions = getWalkablePositions();
  const chestMeshes = [];
  const mixers = [];

  function placeChests() {
    const positions = new Set();
    while (positions.size < 12 && walkablePositions.length) {
      const pos = walkablePositions[Math.floor(Math.random() * walkablePositions.length)];
      if (pos.x === spawn.x && pos.z === spawn.z) continue;
      positions.add(`${pos.x},${pos.z}`);
    }

    Array.from(positions).forEach(str => {
      const [x, z] = str.split(',').map(Number);
      gltfLoader.load('./assets/chest.glb', gltf => {
        const chest = gltf.scene;
        chest.traverse(c => {
          if (!c.isMesh) return;
          if (c.name.toLowerCase().includes('lid')) {
            c.material = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
          } else {
            c.material = new THREE.MeshStandardMaterial({ color: 0x8B4513, metalness: 0.2, roughness: 0.8 });
          }
          c.castShadow = c.receiveShadow = true;
        });
        chest.scale.set(0.9, 0.9, 0.9);
        chest.position.set(x - 0.30, 0.05, z + 0.20);
        scene.add(chest);

        const mixer = new THREE.AnimationMixer(chest);
        const clip = gltf.animations.find(a => a.name.toLowerCase().includes('open')) || gltf.animations[0];
        mixers.push(mixer);

        chestMeshes.push({ mesh: chest, pos: { x, z }, mixer, clip, opened: false });
      });
    });
  }

  placeChests();

  function jumpPlayer(toX, toZ) {
    const start = { x: player.position.x, y: 0.4, z: player.position.z };
    const duration = 400;
    let startTime = null;
    function hop(t) {
      if (!startTime) startTime = t;
      const p = Math.min((t - startTime) / duration, 1);
      const h = Math.sin(p * Math.PI) * 1.2;
      player.position.set(start.x + (toX - start.x) * p, start.y + h, start.z + (toZ - start.z) * p);
      if (p < 1) requestAnimationFrame(hop);
      else player.position.set(toX, 0.4, toZ);
    }
    requestAnimationFrame(hop);
  }

  const cameraOffset = new THREE.Vector3(8, 10, 8);
  camera.position.copy(player.position).add(cameraOffset);
  camera.lookAt(new THREE.Vector3(player.position.x, 0.4, player.position.z));
  const fixedQuat = camera.quaternion.clone();

  let canMove = true;
  const isWalkable = (x, z) => walkablePositions.some(p => p.x === x && p.z === z);

  window.addEventListener('keydown', e => {
    if (!canMove) return;
    let moved = false;
    if (e.key === 'ArrowUp' && isWalkable(playerPos.x, playerPos.z - 1)) { playerPos.z--; moved = true; }
    if (e.key === 'ArrowDown' && isWalkable(playerPos.x, playerPos.z + 1)) { playerPos.z++; moved = true; }
    if (e.key === 'ArrowLeft' && isWalkable(playerPos.x - 1, playerPos.z)) { playerPos.x--; moved = true; }
    if (e.key === 'ArrowRight' && isWalkable(playerPos.x + 1, playerPos.z)) { playerPos.x++; moved = true; }
    if (!moved) return;

    jumpPlayer(playerPos.x, playerPos.z);
    for (let i = 0; i < chestMeshes.length; i++) {
      const c = chestMeshes[i];
      if (c.pos.x === playerPos.x && c.pos.z === playerPos.z && !c.opened) {
        c.opened = true;
        c.mixer.clipAction(c.clip).reset().play();
        createSparkleEffect(c.pos.x, 0.6, c.pos.z);
        setTimeout(() => {
          scene.remove(c.mesh);
          chestMeshes.splice(i, 1);
          canMove = false;
          showModal();
        }, 1000);
        break;
      }
    }
  });

  function createSparkleEffect(x, y, z) {
    const group = new THREE.Group();
    scene.add(group);
    group.position.set(x, y, z);

    const sparkleCount = 40;
    for (let i = 0; i < sparkleCount; i++) {
      const color = new THREE.Color(`hsl(${Math.random() * 60 + 40}, 100%, 70%)`);
      const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
      const geometry = new THREE.SphereGeometry(0.07, 6, 6);
      const sparkle = new THREE.Mesh(geometry, material);
      sparkle.position.set((Math.random() - 0.5) * 1.5, Math.random() * 1.0, (Math.random() - 0.5) * 1.5);
      sparkle.userData = {
        velocityY: 0.01 + Math.random() * 0.015,
        rotationSpeed: Math.random() * 0.1,
        fadeSpeed: 0.015 + Math.random() * 0.01
      };
      group.add(sparkle);
    }

    const animateSparkles = () => {
      group.children.forEach(s => {
        s.position.y += s.userData.velocityY;
        s.rotation.y += s.userData.rotationSpeed;
        s.material.opacity -= s.userData.fadeSpeed;
      });
      group.children = group.children.filter(s => {
        if (s.material.opacity <= 0) {
          group.remove(s);
          return false;
        }
        return true;
      });
      if (group.children.length > 0) requestAnimationFrame(animateSparkles);
      else scene.remove(group);
    };
    animateSparkles();
  }

  const modal = document.getElementById('modal');
  const closeBtn = document.getElementById('closeBtn');
  const showModal = () => modal.style.display = 'flex';
  const closeModal = () => { modal.style.display = 'none'; canMove = true; };
  closeBtn.addEventListener('click', closeModal);

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  function animate() {
    requestAnimationFrame(animate);
    const target = new THREE.Vector3(player.position.x + cameraOffset.x, camera.position.y, player.position.z + cameraOffset.z);
    camera.position.lerp(target, 0.08);
    camera.quaternion.copy(fixedQuat);

    const delta = clock.getDelta();
    mixers.forEach(m => m.update(delta));
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
